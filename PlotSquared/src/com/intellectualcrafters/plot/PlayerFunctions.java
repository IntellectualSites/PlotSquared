/*
 * Copyright (c) IntellectualCrafters - 2014. You are not allowed to distribute
 * and/or monetize any of our intellectual property. IntellectualCrafters is not
 * affiliated with Mojang AB. Minecraft is a trademark of Mojang AB.
 * 
 * >> File = PlayerFunctions.java >> Generated by: Citymonstret at 2014-08-09
 * 01:43
 */

package com.intellectualcrafters.plot;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.OfflinePlayer;
import org.bukkit.WeatherType;
import org.bukkit.World;
import org.bukkit.block.Biome;
import org.bukkit.entity.Player;

/**
 * Functions involving players, plots and locations.
 *
 * @author Citymonstret
 */
@SuppressWarnings("javadoc")
public class PlayerFunctions {

	/**
	 * @param player
	 *            player
	 * @return
	 */
	public static boolean isInPlot(Player player) {
		return getCurrentPlot(player) != null;
	}

	/**
	 * @param plot
	 *            plot
	 * @return
	 */
	public static boolean hasExpired(Plot plot) {
		OfflinePlayer player = Bukkit.getOfflinePlayer(plot.owner);
		long lp = player.getLastPlayed();
		long cu = System.currentTimeMillis();
		return (lp - cu) > 30l;
	}

	public static ArrayList<PlotId> getPlotSelectionIds(World world, PlotId pos1, PlotId pos2) {
        ArrayList<PlotId> myplots = new ArrayList<PlotId>();
        for (int x = pos1.x; x <= pos2.x; x++) {
            for (int y = pos1.y; y <= pos2.y; y++) {
                myplots.add(new PlotId(x, y));
            }
        }
        return myplots;
    }
	
	public static ArrayList<PlotId> getMaxPlotSelectionIds(World world, PlotId pos1, PlotId pos2) {
	    
	    Plot plot1 = PlotMain.getPlots(world).get(pos1);
	    Plot plot2 = PlotMain.getPlots(world).get(pos2);
	    
	    if (plot1 != null) {
            pos1 = getBottomPlot(world, plot1).id;
        }
	    
	    if (plot2 != null) {
            pos2 = getTopPlot(world, plot2).id;
        }
	    
        ArrayList<PlotId> myplots = new ArrayList<PlotId>();
        for (int x = pos1.x; x <= pos2.x; x++) {
            for (int y = pos1.y; y <= pos2.y; y++) {
                myplots.add(new PlotId(x, y));
            }
        }
        return myplots;
    }

	public static Plot getBottomPlot(World world, Plot plot) {
		if (plot.settings.getMerged(0)) {
			return getBottomPlot(world, PlotMain.getPlots(world).get(new PlotId(plot.id.x, plot.id.y - 1)));
		}
		if (plot.settings.getMerged(3)) {
			return getBottomPlot(world, PlotMain.getPlots(world).get(new PlotId(plot.id.x - 1, plot.id.y)));
		}
		return plot;
	}

	public static Plot getTopPlot(World world, Plot plot) {
		if (plot.settings.getMerged(2)) {
			return getTopPlot(world, PlotMain.getPlots(world).get(new PlotId(plot.id.x, plot.id.y + 1)));
		}
		if (plot.settings.getMerged(1)) {
			return getTopPlot(world, PlotMain.getPlots(world).get(new PlotId(plot.id.x + 1, plot.id.y)));
		}
		return plot;
	}

	/**
	 * Returns the plot at a location (mega plots are not considered, all plots are treated as small plots)
	 * @param loc
	 * @return
	 */
	public static PlotId getPlotAbs(Location loc) {
		String world = loc.getWorld().getName();
		PlotManager manager = PlotMain.getPlotManager(world);
		if (manager == null) {
			return null;
		}
		PlotWorld plotworld = PlotMain.getWorldSettings(world);
		return manager.getPlotIdAbs(plotworld, loc);
	}

	/**
	 * Returns the plot id at a location (mega plots are considered)
	 * @param loc
	 * @return
	 */
	public static PlotId getPlot(Location loc) {
		String world = loc.getWorld().getName();
		PlotManager manager = PlotMain.getPlotManager(world);
		if (manager == null) {
			return null;
		}
		PlotWorld plotworld = PlotMain.getWorldSettings(world);
		return manager.getPlotId(plotworld, loc);
	}

	/**
	 * Sets the weather for a player, given the current plot settings
	 * @param player
	 * @param plot
	 */
	public static void togglePlotWeather(Player player, Plot plot) {
		player.setPlayerWeather(plot.settings.getRain() ? WeatherType.DOWNFALL : WeatherType.CLEAR);
	}

	/**
	 * Sets the time for a player, given the current plot settings
	 * @param player
	 * @param plot
	 */
	public static void togglePlotTime(Player player, Plot plot) {
		player.setPlayerTime(plot.settings.getTime(), false);
	}

	/**
	 * Returns the plot a player is currently in.
	 * @param player
	 * @return
	 */
	public static Plot getCurrentPlot(Player player) {
		if (!PlotMain.isPlotWorld(player.getWorld())) {
			return null;
		}
		PlotId id = getPlot(player.getLocation());
		World world = player.getWorld();
		if (id == null) {
			return null;
		}
		HashMap<PlotId, Plot> plots = PlotMain.getPlots(world);
		if (plots != null) {
			if (plots.containsKey(id)) {
				return plots.get(id);
			}
		}
		return new Plot(id, null, Biome.FOREST, new ArrayList<UUID>(), new ArrayList<UUID>(), world.getName());

	}

	/**
	 * Updates a given plot with another instance
	 * @deprecated
	 * @param id
	 * @param plot
	 */
	@Deprecated
	public static void set(Plot plot) {
		PlotMain.updatePlot(plot);
	}

	/**
	 * Get the plots for a player
	 * @param plr
	 * @return
	 */
	public static Set<Plot> getPlayerPlots(World world, Player plr) {
		Set<Plot> p = PlotMain.getPlots(world, plr);
		if (p == null) {
			return new HashSet<Plot>();
		}
		return p;
	}

	/**
	 * Get the number of plots for a player
	 * @param plr
	 * @return
	 */
	public static int getPlayerPlotCount(World world, Player plr) {
		return getPlayerPlots(world, plr).size();
	}

	/**
	 * Get the maximum number of plots a player is allowed
	 * @param p
	 * @return
	 */
	@SuppressWarnings("SuspiciousNameCombination")
	public static int getAllowedPlots(Player p) {
		return PlotMain.hasPermissionRange(p, "plots.plot", Settings.MAX_PLOTS);
	}

	/**
	 * @return PlotMain.getPlots();
	 * @deprecated
	 */
	@Deprecated
	public static Set<Plot> getPlots() {
		return PlotMain.getPlots();
	}

	/**
	 * \\previous\\
	 * 
	 * @param plr
	 * @param msg
	 *            Was used to wrap the chat client length (Packets out--)
	 */
	public static void sendMessageWrapped(Player plr, String msg) {
		plr.sendMessage(msg);
	}

	/**
	 * Send a message to the player
	 * 
	 * @param plr
	 *            Player to recieve message
	 * @param msg
	 *            Message to send
	 */
	public static void sendMessage(Player plr, String msg) {
		if ((msg.length() == 0) || msg.equalsIgnoreCase("")) {
			return;
		}
		
		if (plr==null) {
			PlotMain.sendConsoleSenderMessage(C.PREFIX.s() + msg);
			return;
		}
		
		sendMessageWrapped(plr, ChatColor.translateAlternateColorCodes('&', C.PREFIX.s() + msg));
	}

	/**
	 * Send a message to the player
	 * 
	 * @param plr
	 *            Player to recieve message
	 * @param c
	 *            Caption to send
	 */
	public static void sendMessage(Player plr, C c, String... args) {
		
		if (plr==null) {
			PlotMain.sendConsoleSenderMessage(c);
			return;
		}
		
		if (c.s().length() < 1) {
			return;
		}
		String msg = c.s();
		if ((args != null) && (args.length > 0)) {
			for (String str : args) {
				msg = msg.replaceFirst("%s", str);
			}
		}
		sendMessage(plr, msg);
	}
}
