/*
 * Copyright (c) IntellectualCrafters - 2014.
 * You are not allowed to distribute and/or monetize any of our intellectual property.
 * IntellectualCrafters is not affiliated with Mojang AB. Minecraft is a trademark of Mojang AB.
 *
 * >> File = PlotHelper.java
 * >> Generated by: Citymonstret at 2014-08-09 01:43
 */

package com.intellectualcrafters.plot;

import com.intellectualcrafters.plot.database.DBFunc;
import net.milkbowl.vault.economy.Economy;
import org.bukkit.*;
import org.bukkit.block.Biome;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.block.Sign;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;

import java.io.File;
import java.util.*;

/**
 * plot functions
 * 
 * @author Citymonstret
 * 
 */
public class PlotHelper {
    public static boolean canSetFast = false;
    static long state = 1;

    private static double calculateNeededTime(double blocks, double blocks_per_second) {
        return (blocks / blocks_per_second);
    }

    /**
     * direction 0 = north, 1 = south, etc:
     * 
     * @param id
     * @param direction
     * @return
     */
    public static PlotId getPlotIdRelative(PlotId id, int direction) {
        switch (direction) {
        case 0:
            return new PlotId(id.x, id.y - 1);
        case 1:
            return new PlotId(id.x + 1, id.y);
        case 2:
            return new PlotId(id.x, id.y + 1);
        case 3:
            return new PlotId(id.x - 1, id.y);
        }
        return id;
    }

    public static boolean mergePlots(Player plr, World world, ArrayList<PlotId> plotIds) {
        PlotWorld plotworld = PlotMain.getWorldSettings(world);
        if(PlotMain.useEconomy && plotworld.USE_ECONOMY) {
            double cost = plotIds.size() * plotworld.MERGE_PRICE;
            if (cost > 0d) {
                Economy economy = PlotMain.economy;
                if (economy.getBalance(plr) < cost) {
                    PlayerFunctions.sendMessage(plr, C.CANNOT_AFFORD_MERGE, "" + cost);
                    return false;
                }
                economy.withdrawPlayer(plr, cost);
                PlayerFunctions.sendMessage(plr, C.REMOVED_BALANCE, cost + "");
            }
        }
        return mergePlots(world, plotIds);
    }

    /**
     * Completely merges a set of plots<br>
     * <b>(There are no checks to make sure you supply the correct
     * arguments)</b><br>
     * - Misuse of this method can result in unusable plots<br>
     * - the set of plots must belong to one owner and be rectangular<br>
     * - the plot array must be sorted in ascending order<br>
     * - Road will be removed where required<br>
     * - changes will be saved to DB<br>
     * 
     * @param world
     * @param plotIds
     * @return boolean (success)
     */
    public static boolean mergePlots(World world, ArrayList<PlotId> plotIds) {
        PlotWorld plotworld = PlotMain.getWorldSettings(world);
        int pathsize = plotworld.ROAD_WIDTH;
        int plotheight = plotworld.PLOT_HEIGHT;

        if (plotIds.size() < 2) {
            return false;
        }

        final short[] plotfloors = new short[plotworld.TOP_BLOCK.length];
        final short[] plotfloors_data = new short[plotworld.TOP_BLOCK.length];

        final short[] filling = new short[plotworld.MAIN_BLOCK.length];
        final short[] filling_data = new short[plotworld.MAIN_BLOCK.length];

        for (int i = 0; i < plotworld.TOP_BLOCK.length; i++) {
            short[] result = getBlock(plotworld.TOP_BLOCK[i]);
            plotfloors[i] = result[0];
            plotfloors_data[i] = result[1];
        }
        for (int i = 0; i < plotworld.MAIN_BLOCK.length; i++) {
            short[] result = getBlock(plotworld.MAIN_BLOCK[i]);
            filling[i] = result[0];
            filling_data[i] = result[1];
        }

        PlotId pos1 = plotIds.get(0);
        PlotId pos2 = plotIds.get(plotIds.size() - 1);

        for (int x = pos1.x; x <= pos2.x; x++) {
            for (int y = pos1.y; y <= pos2.y; y++) {

                boolean lx = x < pos2.x;
                boolean ly = y < pos2.y;

                PlotId id = new PlotId(x, y);
                Plot plot = PlotMain.getPlots(world).get(id);

                if (lx) {
                    if (ly) {
                        if (!plot.settings.getMerged(1) || !plot.settings.getMerged(2)) {
                            Location loc = getPlotTopLocAbs(world, id);

                            int sx = loc.getBlockX() + 1;
                            int ex = (sx + pathsize) - 1;
                            int sz = loc.getBlockZ() + 1;
                            int ez = (sz + pathsize) - 1;

                            PlotHelper.setSimpleCuboid(world, new Location(world, sx, plotheight + 1, sz), new Location(world, ex + 1, 257 + 1, ez + 1), (short) 0);

                            PlotHelper.setCuboid(world, new Location(world, sx + 1, 1, sz + 1), new Location(world, ex, plotheight, ez), filling, filling_data);
                            PlotHelper.setCuboid(world, new Location(world, sx + 1, plotheight, sz + 1), new Location(world, ex, plotheight + 1, ez), plotfloors, plotfloors_data);
                        }
                    }
                    if (!plot.settings.getMerged(1)) {
                        Plot plot2 = PlotMain.getPlots(world).get(new PlotId(x + 1, y));
                        mergePlot(world, plot, plot2);
                        plot.settings.setMerged(1, true);
                        plot2.settings.setMerged(3, true);
                    }
                }
                if (ly) {
                    if (!plot.settings.getMerged(2)) {
                        Plot plot2 = PlotMain.getPlots(world).get(new PlotId(x, y + 1));
                        mergePlot(world, plot, plot2);
                        plot.settings.setMerged(2, true);
                        plot2.settings.setMerged(0, true);
                    }
                }

            }
        }

        Location megaPlotBot = getPlotBottomLoc(world, pos1);
        Location megaPlotTop = getPlotTopLoc(world, pos2).add(1, 0, 1);

        short[] result_w = PlotHelper.getBlock(plotworld.WALL_BLOCK);
        short w_id = result_w[0];
        byte w_v = (byte) result_w[1];

        for (int x = megaPlotBot.getBlockX(); x <= megaPlotTop.getBlockX(); x++) {
            for (int z = megaPlotBot.getBlockZ(); z <= megaPlotTop.getBlockZ(); z++) {
                if ((z == megaPlotBot.getBlockZ()) || (z == megaPlotTop.getBlockZ()) || (x == megaPlotBot.getBlockX()) || (x == megaPlotTop.getBlockX())) {
                    world.getBlockAt(x, plotworld.WALL_HEIGHT + 1, z).setTypeIdAndData(w_id, w_v, false);
                }
            }
        }

        return true;
    }

    /**
     * Merges 2 plots Removes the road inbetween <br>
     * - Assumes the first plot parameter is lower <br>
     * - Assumes neither are a Mega-plot <br>
     * - Assumes plots are directly next to each other <br>
     * - Saves to DB
     * 
     * @param world
     * @param lesserPlot
     * @param greaterPlot
     */
    public static void mergePlot(World world, Plot lesserPlot, Plot greaterPlot) {
        Location pos1 = getPlotBottomLocAbs(world, lesserPlot.id).add(1, 0, 1);
        Location pos2 = getPlotTopLocAbs(world, lesserPlot.id);

        Location pos3 = getPlotBottomLocAbs(world, greaterPlot.id).add(1, 0, 1);
        Location pos4 = getPlotTopLocAbs(world, greaterPlot.id);

        int sx = Math.max(pos1.getBlockX(), pos2.getBlockX());
        int ex = Math.min(pos3.getBlockX(), pos4.getBlockX());
        int sz = Math.max(pos1.getBlockZ(), pos2.getBlockZ());
        int ez = Math.min(pos3.getBlockZ(), pos4.getBlockZ());

        int startx = Math.min(sx, ex);
        int startz = Math.min(sz, ez);
        int endx = Math.max(sx, ex) + 1;
        int endz = Math.max(sz, ez) + 1;

        PlotWorld plotworld = PlotMain.getWorldSettings(world);

        final short[] plotfloors = new short[plotworld.TOP_BLOCK.length];
        final short[] plotfloors_data = new short[plotworld.TOP_BLOCK.length];

        final short[] filling = new short[plotworld.MAIN_BLOCK.length];
        final short[] filling_data = new short[plotworld.MAIN_BLOCK.length];

        for (int i = 0; i < plotworld.TOP_BLOCK.length; i++) {
            short[] result = getBlock(plotworld.TOP_BLOCK[i]);
            plotfloors[i] = result[0];
            plotfloors_data[i] = result[1];
        }
        for (int i = 0; i < plotworld.MAIN_BLOCK.length; i++) {
            short[] result = getBlock(plotworld.MAIN_BLOCK[i]);
            filling[i] = result[0];
            filling_data[i] = result[1];
        }

        boolean noMerge = false;

        if (lesserPlot.id.x == greaterPlot.id.x) {

            noMerge = lesserPlot.settings.getMerged(2);

            lesserPlot.settings.setMerged(2, true);
            greaterPlot.settings.setMerged(0, true);
            startx--;
            endx++;
        } else {

            noMerge = lesserPlot.settings.getMerged(1);

            lesserPlot.settings.setMerged(1, true);
            greaterPlot.settings.setMerged(3, true);
            startz--;
            endz++;
        }
        if (!noMerge) {
            DBFunc.setMerged(world.getName(), lesserPlot, lesserPlot.settings.getMerged());
            DBFunc.setMerged(world.getName(), greaterPlot, greaterPlot.settings.getMerged());
            setSimpleCuboid(world, new Location(world, startx, 0, startz), new Location(world, endx, 1, endz), (short) 7);
            setSimpleCuboid(world, new Location(world, startx, plotworld.PLOT_HEIGHT + 1, startz), new Location(world, endx, world.getMaxHeight(), endz), (short) 0);
            setCuboid(world, new Location(world, startx, 1, startz), new Location(world, endx, plotworld.PLOT_HEIGHT, endz), filling, filling_data);
            setCuboid(world, new Location(world, startx, plotworld.PLOT_HEIGHT, startz), new Location(world, endx, plotworld.PLOT_HEIGHT + 1, endz), plotfloors, plotfloors_data);
        }
    }

    public static final long nextLong() {
        long a = state;
        state = xorShift64(a);
        return a;
    }

    public static final long xorShift64(long a) {
        a ^= (a << 21);
        a ^= (a >>> 35);
        a ^= (a << 4);
        return a;
    }

    public static final int random(int n) {
        if (n == 1) {
            return 0;
        }
        long r = ((nextLong() >>> 32) * n) >> 32;
        return (int) r;
    }

    public static void removeSign(Player plr, Plot p) {
        PlotWorld plotworld = PlotMain.getWorldSettings(Bukkit.getWorld(p.world));
        Location pl = new Location(plr.getWorld(), getPlotBottomLoc(plr.getWorld(), p.id).getBlockX(), plotworld.ROAD_HEIGHT + 1, getPlotBottomLoc(plr.getWorld(), p.id).getBlockZ());
        Block bs = pl.add(0, 0, -1).getBlock();
        bs.setType(Material.AIR);
    }

    @SuppressWarnings("deprecation")
    public static void setSign(Player plr, Plot p) {
        World world = Bukkit.getWorld(p.world);
        PlotWorld plotworld = PlotMain.getWorldSettings(world);
        Location pl = new Location(world, getPlotBottomLoc(world, p.id).getBlockX(), plotworld.ROAD_HEIGHT + 1, getPlotBottomLoc(world, p.id).getBlockZ());
        Block bs = pl.add(0, 0, -1).getBlock();
        bs.setType(Material.AIR);
        bs.setTypeIdAndData(Material.WALL_SIGN.getId(), (byte) 2, false);
        String id = p.id.y + ";" + p.id.x;
        Sign sign = (Sign) bs.getState();
        sign.setLine(0, C.OWNER_SIGN_LINE_1.translated().replaceAll("%id%", id));
        sign.setLine(1, C.OWNER_SIGN_LINE_2.translated().replaceAll("%id%", id).replaceAll("%plr%", plr.getName()));
        sign.setLine(2, C.OWNER_SIGN_LINE_3.translated().replaceAll("%id%", id).replaceAll("%plr%", plr.getName()));
        sign.setLine(3, C.OWNER_SIGN_LINE_4.translated().replaceAll("%id%", id).replaceAll("%plr%", plr.getName()));
        sign.update(true);
    }

    public static String getPlayerName(UUID uuid) {
        if (uuid == null) {
            return "unknown";
        }
        OfflinePlayer plr = Bukkit.getOfflinePlayer(uuid);
        if (plr == null) {
            return "unknown";
        }
        return plr.getName();
    }

    public static String getStringSized(int max, String string) {
        if (string.length() > max) {
            return string.substring(0, max);
        }
        return string;
    }

    public static void adjustWall(World w, Plot plot, short id, byte data) {

        PlotWorld plotworld = PlotMain.getWorldSettings(Bukkit.getWorld(plot.world));

        List<String> wallIds = new ArrayList<String>();

        wallIds.add("" + id + ":" + data);

        Location bottom = getPlotBottomLoc(w, plot.id);
        Location top = getPlotTopLoc(w, plot.id);

        int x, z;

        Block block;

        for (x = bottom.getBlockX(); x < (top.getBlockX() + 1); x++) {
            z = bottom.getBlockZ();

            block = w.getBlockAt(x, plotworld.ROAD_HEIGHT + 1, z);
            setWall(block, "" + id + ":" + data);
        }

        for (z = bottom.getBlockZ(); z < (top.getBlockZ() + 1); z++) {
            x = top.getBlockX() + 1;

            block = w.getBlockAt(x, plotworld.ROAD_HEIGHT + 1, z);
            setWall(block, "" + id + ":" + data);
        }

        for (x = top.getBlockX() + 1; x > (bottom.getBlockX() - 1); x--) {
            z = top.getBlockZ() + 1;

            block = w.getBlockAt(x, plotworld.ROAD_HEIGHT + 1, z);
            setWall(block, "" + id + ":" + data);
        }

        for (z = top.getBlockZ() + 1; z > (bottom.getBlockZ() - 1); z--) {
            x = bottom.getBlockX();
            block = w.getBlockAt(x, plotworld.ROAD_HEIGHT + 1, z);
            setWall(block, "" + id + ":" + data);
        }
    }

    public static void autoMerge(World world, Plot plot, Player player) {
        if (plot == null) {
            return;
        }
        if (plot.owner == null) {
            return;
        }
        if (!plot.owner.equals(player.getUniqueId())) {
            return;
        }

        ArrayList<PlotId> plots;
        boolean merge = true;
        while (merge) {
            PlotId bot = PlayerFunctions.getBottomPlot(world, plot).id;
            PlotId top = PlayerFunctions.getTopPlot(world, plot).id;
            merge = false;
            plots = PlayerFunctions.getPlotSelectionIds(world, new PlotId(bot.x, bot.y - 1), new PlotId(top.x, top.y));
            if (ownsPlots(world, plots, player, 0)) {
                merge = true;
                mergePlots(world, plots);
                continue;
            }
            plots = PlayerFunctions.getPlotSelectionIds(world, new PlotId(bot.x, bot.y), new PlotId(top.x + 1, top.y));
            if (ownsPlots(world, plots, player, 1)) {
                merge = true;
                mergePlots(world, plots);
                continue;
            }
            plots = PlayerFunctions.getPlotSelectionIds(world, new PlotId(bot.x, bot.y), new PlotId(top.x, top.y + 1));
            if (ownsPlots(world, plots, player, 2)) {
                merge = true;
                mergePlots(world, plots);
                continue;
            }
            plots = PlayerFunctions.getPlotSelectionIds(world, new PlotId(bot.x - 1, bot.y), new PlotId(top.x, top.y));
            if (ownsPlots(world, plots, player, 3)) {
                merge = true;
                mergePlots(world, plots);
                continue;
            }
        }
        if (canSetFast) {
            SetBlockFast.update(player);
        }
    }

    private static boolean ownsPlots(World world, ArrayList<PlotId> plots, Player player, int dir) {
        PlotId id_min = plots.get(0);
        PlotId id_max = plots.get(plots.size() - 1);
        for (PlotId myid : plots) {
            Plot myplot = PlotMain.getPlots(world).get(myid);
            if ((myplot == null) || !myplot.hasOwner() || !(myplot.getOwner().equals(player.getUniqueId()))) {
                return false;
            }
            PlotId top = PlayerFunctions.getTopPlot(world, myplot).id;
            if (((top.x > id_max.x) && (dir != 1)) || ((top.y > id_max.y) && (dir != 2))) {
                return false;
            }
            PlotId bot = PlayerFunctions.getBottomPlot(world, myplot).id;
            if (((bot.x < id_min.x) && (dir != 3)) || ((bot.y < id_min.y) && (dir != 0))) {
                return false;
            }
        }
        return true;
    }

    public static boolean createPlot(Player player, Plot plot) {
        World w = plot.getWorld();
        Plot p = new Plot(plot.id, player.getUniqueId(), plot.settings.getBiome(), new ArrayList<UUID>(), new ArrayList<UUID>(), w.getName());
        PlotMain.updatePlot(p);
        DBFunc.createPlot(p);
        DBFunc.createPlotSettings(DBFunc.getId(w.getName(), p.id), p);
        PlotWorld plotworld = PlotMain.getWorldSettings(w);
        if (plotworld.AUTO_MERGE) {
            autoMerge(w, p, player);
        }

        return true;
    }

    public static int getLoadedChunks(World world) {
        return world.getLoadedChunks().length;
    }

    public static int getEntities(World world) {
        return world.getEntities().size();
    }

    public static int getTileEntities(World world) {
        PlotMain.getWorldSettings(world);
        int x = 0;
        for (Chunk chunk : world.getLoadedChunks()) {
            x += chunk.getTileEntities().length;
        }
        return x;
    }

    public static double getWorldFolderSize(World world) {
        // long size = FileUtil.sizeOfDirectory(world.getWorldFolder());
        File folder = world.getWorldFolder();
        long size = folder.length();
        return (((size) / 1024) / 1024);
    }

    // public static void adjustLinkedPlots(String id) {
    // World world = Bukkit.getWorld(Settings.PLOT_WORLD);
    // int x = getIdX(id);
    // int z = getIdZ(id);
    //
    // plot p11 = getPlot(id);
    // if (p11 != null) {
    // plot p01, p10, p12, p21, p00, p02, p20, p22;
    // p01 = getPlot(x - 1, z);
    // p10 = getPlot(x, z - 1);
    // p12 = getPlot(x, z + 1);
    // p21 = getPlot(x + 1, z);
    // p00 = getPlot(x - 1, z - 1);
    // p02 = getPlot(x - 1, z + 1);
    // p20 = getPlot(x + 1, z - 1);
    // p22 = getPlot(x + 1, z + 1);
    // if (p01 != null && p01.owner.equals(p11.owner)) {
    // fillroad(p01, p11, world);
    // }
    //
    // if (p10 != null && p10.owner.equals(p11.owner)) {
    // fillroad(p10, p11, world);
    // }
    //
    // if (p12 != null && p12.owner.equals(p11.owner)) {
    // fillroad(p12, p11, world);
    // }
    //
    // if (p21 != null && p21.owner.equals(p11.owner)) {
    // fillroad(p21, p11, world);
    // }
    //
    // if (p00 != null && p10 != null && p01 != null
    // && p00.owner.equals(p11.owner)
    // && p11.owner.equals(p10.owner)
    // && p10.owner.equals(p01.owner)) {
    // fillmiddleroad(p00, p11, world);
    // }
    //
    // if (p10 != null && p20 != null && p21 != null
    // && p10.owner.equals(p11.owner)
    // && p11.owner.equals(p20.owner)
    // && p20.owner.equals(p21.owner)) {
    // fillmiddleroad(p20, p11, world);
    // }
    //
    // if (p01 != null && p02 != null && p12 != null
    // && p01.owner.equals(p11.owner)
    // && p11.owner.equals(p02.owner)
    // && p02.owner.equals(p12.owner)) {
    // fillmiddleroad(p02, p11, world);
    // }
    //
    // if (p12 != null && p21 != null && p22 != null
    // && p12.owner.equals(p11.owner)
    // && p11.owner.equals(p21.owner)
    // && p21.owner.equals(p22.owner)) {
    // fillmiddleroad(p22, p11, world);
    // }
    // }
    // }
    //
    // public static void fillroad(plot plot1, plot plot2, World w) {
    // Location bottomPlot1, topPlot1, bottomPlot2, topPlot2;
    // bottomPlot1 = getPlotBottomLoc(w, plot1.id);
    // topPlot1 = getPlotTopLoc(w, plot1.id);
    // bottomPlot2 = getPlotBottomLoc(w, plot2.id);
    // topPlot2 = getPlotTopLoc(w, plot2.id);
    //
    // int minX, maxX, minZ, maxZ;
    //
    // boolean isWallX;
    //
    // int h = Settings.ROAD_HEIGHT;
    // int wallId = Settings.WALL_BLOCK;
    // int fillId = Settings.TOP_BLOCK;
    //
    // if(bottomPlot1.getBlockX() == bottomPlot2.getBlockX()) {
    // minX = bottomPlot1.getBlockX();
    // maxX = topPlot1.getBlockX();
    //
    // minZ = Math.min(bottomPlot1.getBlockZ(), bottomPlot2.getBlockZ()) +
    // Settings.PLOT_WIDTH;
    // maxZ = Math.min(topPlot1.getBlockZ(), topPlot2.getBlockZ()) -
    // Settings.PLOT_WIDTH;
    // } else {
    // minZ = bottomPlot1.getBlockZ();
    // maxZ = topPlot1.getBlockZ();
    //
    // minX = Math.min(bottomPlot1.getBlockX(), bottomPlot2.getBlockX()) +
    // Settings.PLOT_WIDTH;
    // maxX = Math.max(topPlot1.getBlockX(), topPlot2.getBlockX()) -
    // Settings.PLOT_WIDTH;
    // }
    //
    // isWallX = (maxX - minX) > (maxZ - minZ);
    //
    // if(isWallX) {
    // minX--;
    // maxX++;
    // } else {
    // minZ--;
    // maxZ++;
    // }
    //
    // for(int x = minX; x <= maxX; x++) {
    // for(int z = minZ; x <= maxZ; z++) {
    // for(int y = h; y < h + 3; y++) {
    // if(y >= (h + 2)) {
    // w.getBlockAt(x,y,z).setType(Material.AIR);
    // } else if(y == (h + 1)) {
    // if(isWallX && (x == minX || x == maxX)) {
    // w.getBlockAt(x,y,z).setTypeIdAndData(wallId, (byte) 0, true);
    // } else if(!isWallX && (z == minZ || z == maxZ)) {
    // w.getBlockAt(x,y,z).setTypeIdAndData(wallId, (byte) 0, true);
    // } else {
    // w.getBlockAt(x,y,z).setType(Material.AIR);
    // }
    // } else {
    // w.getBlockAt(x,y,z).setTypeIdAndData(fillId, (byte) 0, true);
    // }
    // }
    // }
    // }
    // }
    //
    // public static void fillmiddleroad(plot p1, plot p2, World w) {
    // Location b1 = getPlotBottomLoc(w, p1.id);
    // Location t1 = getPlotTopLoc(w, p1.id);
    // Location b2 = getPlotBottomLoc(w, p2.id);
    // Location t2 = getPlotTopLoc(w, p2.id);
    //
    // int minX, maxX, minZ, maxZ;
    //
    // int h = Settings.ROAD_HEIGHT;
    // int fillID = Settings.TOP_BLOCK;
    //
    // minX = Math.min(t1.getBlockX(), t2.getBlockX());
    // maxX = Math.max(b1.getBlockX(), b2.getBlockX());
    //
    // minZ = Math.min(t1.getBlockZ(), t2.getBlockZ());
    // maxZ = Math.max(b1.getBlockZ(), b2.getBlockZ());
    //
    // for(int x = minX; x <= maxX; x++) {
    // for(int z = minZ; z <= maxZ; z++) {
    // for(int y = h; y < h + 3; y++) {
    // if(y >= (h + 1)) {
    // w.getBlockAt(x,y,z).setType(Material.AIR);
    // } else {
    // w.getBlockAt(x,y,z).setTypeId(fillID);
    // }
    // }
    // }
    // }
    // }

    public static String createId(int x, int z) {
        return x + ";" + z;
    }

    public static ArrayList<String> runners_p = new ArrayList<String>();
    public static HashMap<Plot, Integer> runners = new HashMap<Plot, Integer>();

    public static void adjustWallFilling(final Player requester, final World w, final Plot plot, final short id, final byte data) {
        if (runners.containsKey(plot)) {
            PlayerFunctions.sendMessage(requester, C.WAIT_FOR_TIMER);
            return;
        }
        PlayerFunctions.sendMessage(requester, C.GENERATING_WALL_FILLING);
        final PlotWorld plotworld = PlotMain.getWorldSettings(w);
        runners.put(plot, Bukkit.getScheduler().scheduleSyncRepeatingTask(PlotMain.getMain(), new Runnable() {
            Location bottom = getPlotBottomLoc(w, plot.id);
            Location top = getPlotTopLoc(w, plot.id);
            int y = plotworld.ROAD_HEIGHT;
            int x, z;

            @Override
            public void run() {
                for (this.x = this.bottom.getBlockX(); this.x < (this.top.getBlockX() + 1); this.x++) {
                    this.z = this.bottom.getBlockZ();
                    setWall(w.getBlockAt(this.x, this.y, this.z), "" + id + ":" + data);
                }

                for (this.z = this.bottom.getBlockZ(); this.z < (this.top.getBlockZ() + 1); this.z++) {
                    this.x = this.top.getBlockX() + 1;
                    setWall(w.getBlockAt(this.x, this.y, this.z), "" + id + ":" + data);
                }

                for (this.x = this.top.getBlockX() + 1; this.x > (this.bottom.getBlockX() - 1); this.x--) {
                    this.z = this.top.getBlockZ() + 1;
                    setWall(w.getBlockAt(this.x, this.y, this.z), "" + id + ":" + data);
                }

                for (this.z = this.top.getBlockZ() + 1; this.z > (this.bottom.getBlockZ() - 1); this.z--) {
                    this.x = this.bottom.getBlockX();
                    setWall(w.getBlockAt(this.x, this.y, this.z), "" + id + ":" + data);
                }

                this.y--;
                if (this.y < 1) {
                    int runner = runners.get(plot);
                    runners.remove(plot);
                    PlayerFunctions.sendMessage(requester, C.SET_BLOCK_ACTION_FINISHED);
                    Bukkit.getScheduler().cancelTask(runner);
                }
            }
        }, 0l, 5l));
    }

    public static void setFloor(final Player requester, final Plot plot, final Material material[], final byte data[]) {
        final PlotWorld plotworld = PlotMain.getWorldSettings(Bukkit.getWorld(plot.world));
        if (runners.containsKey(plot)) {
            PlayerFunctions.sendMessage(requester, C.WAIT_FOR_TIMER);
            return;
        }
        String time = RUtils.formatTime(calculateNeededTime(square(plotworld.PLOT_WIDTH), 2 * plotworld.PLOT_WIDTH));
        String send = C.GENERATING_FLOOR.s().replaceAll("%time%", time);
        PlayerFunctions.sendMessage(requester, send);
        runners.put(plot, Bukkit.getScheduler().scheduleSyncRepeatingTask(PlotMain.getMain(), new Runnable() {
            World world = Bukkit.getWorld(plot.world);
            int x1 = getPlotBottomLoc(this.world, plot.id).getBlockX();
            int x2 = this.x1 + plotworld.PLOT_WIDTH;
            int z1 = getPlotBottomLoc(this.world, plot.id).getBlockZ();
            int z2 = this.z1 + plotworld.PLOT_WIDTH;

            int xMin = Math.min(this.x1, this.x2) + 1;
            int xMax = Math.max(this.x1, this.x2);

            int zMin = Math.min(this.z1, this.z2) + 1;
            int zMax = Math.max(this.z1, this.z2);
            Random random = new Random();
            int x = this.xMin;

            @SuppressWarnings("deprecation")
            @Override
            public void run() {
                for (int z = this.zMin; z <= this.zMax; z++) {
                    int y = plotworld.PLOT_HEIGHT;
                    byte d;
                    short id;
                    if (material.length > 1) {
                        int index = this.random.nextInt(material.length);
                        d = data[index];
                        id = (short) material[index].getId();
                    } else {
                        d = data[0];
                        id = (short) material[0].getId();
                    }
                    this.world.getBlockAt(this.x, y, z).setTypeIdAndData(id, d, true);
                }
                this.x++;
                if (this.x > this.xMax) {
                    int runner = runners.get(plot);
                    runners.remove(plot);
                    PlayerFunctions.sendMessage(requester, C.SET_BLOCK_ACTION_FINISHED);
                    Bukkit.getScheduler().cancelTask(runner);
                }
            }

        }, 0l, 10l));
    }

    public static int square(int x) {
        return x * x;
    }

    public static int getPlotSize(World world) {
        PlotWorld plotworld = PlotMain.getWorldSettings(world);
        return (square(plotworld.PLOT_WIDTH)) * (world.getMaxHeight());
    }

    public static short[] getBlock(String block) {
        if (block.contains(":")) {
            String[] split = block.split(":");
            return new short[] { Short.parseShort(split[0]), Short.parseShort(split[1]) };
        }
        return new short[] { Short.parseShort(block), 0 };
    }

    public static void clearAllEntities(World world, Plot plot, boolean tile) {
        final Location pos1 = getPlotBottomLoc(world, plot.id).add(1, 0, 1);
        final Location pos2 = getPlotTopLoc(world, plot.id);
        for (int i = (pos1.getBlockX() / 16) * 16; i < (16 + ((pos2.getBlockX() / 16) * 16)); i += 16) {
            for (int j = (pos1.getBlockZ() / 16) * 16; j < (16 + ((pos2.getBlockZ() / 16) * 16)); j += 16) {
                Chunk chunk = world.getChunkAt(i, j);
                for (Entity entity : chunk.getEntities()) {
                    PlotId id = PlayerFunctions.getPlot(entity.getLocation());
                    if ((id != null) && id.equals(plot.id)) {
                        if (entity instanceof Player) {
                            PlotMain.teleportPlayer((Player) entity, entity.getLocation(), plot);
                        } else {
                            entity.remove();
                        }
                    }
                }
                if (tile) {
                    for (BlockState entity : chunk.getTileEntities()) {
                        entity.setRawData((byte) 0);
                    }
                }
            }
        }
    }

    /**
     * Clear a plot
     * 
     * @param requester
     * @param plot
     */
    public static void clear(final Player requester, final Plot plot) {

        final long start = System.nanoTime();
        final World world = requester.getWorld();

        /*
         * keep
         */
        clearAllEntities(world, plot, false);
        final PlotWorld plotworld = PlotMain.getWorldSettings(world);
        PlotHelper.setBiome(requester.getWorld(), plot, Biome.FOREST);
        PlayerFunctions.sendMessage(requester, C.CLEARING_PLOT);
        
        
        final Location pos1 = getPlotBottomLoc(world, plot.id).add(1, 0, 1);
        final Location pos2 = getPlotTopLoc(world, plot.id);

        final short[] plotfloors = new short[plotworld.TOP_BLOCK.length];
        final short[] plotfloors_data = new short[plotworld.TOP_BLOCK.length];

        final short[] filling = new short[plotworld.MAIN_BLOCK.length];
        final short[] filling_data = new short[plotworld.MAIN_BLOCK.length];

        for (int i = 0; i < plotworld.TOP_BLOCK.length; i++) {
            short[] result = getBlock(plotworld.TOP_BLOCK[i]);
            plotfloors[i] = result[0];
            plotfloors_data[i] = result[1];
        }
        for (int i = 0; i < plotworld.MAIN_BLOCK.length; i++) {
            short[] result = getBlock(plotworld.MAIN_BLOCK[i]);
            filling[i] = result[0];
            filling_data[i] = result[1];
        }

        /*
         * keep
         */
        final int prime = 31;
        int h = 1;
        h = (prime * h) + pos1.getBlockX();
        h = (prime * h) + pos1.getBlockZ();
        state = h;

        if ((pos2.getBlockX() - pos1.getBlockX()) < 16) {
            setSimpleCuboid(world, new Location(world, pos1.getBlockX(), 0, pos1.getBlockZ()), new Location(world, pos2.getBlockX() + 1, 1, pos2.getBlockZ() + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, pos1.getBlockX(), plotworld.PLOT_HEIGHT + 1, pos1.getBlockZ()), new Location(world, pos2.getBlockX() + 1, world.getMaxHeight() + 1, pos2.getBlockZ() + 1), (short) 0);
            setCuboid(world, new Location(world, pos1.getBlockX(), 1, pos1.getBlockZ()), new Location(world, pos2.getBlockX() + 1, plotworld.PLOT_HEIGHT, pos2.getBlockZ() + 1), filling, filling_data);
            setCuboid(world, new Location(world, pos1.getBlockX(), plotworld.PLOT_HEIGHT, pos1.getBlockZ()), new Location(world, pos2.getBlockX() + 1, plotworld.PLOT_HEIGHT + 1, pos2.getBlockZ() + 1), plotfloors, plotfloors_data);
            PlayerFunctions.sendMessage(requester, "&c(depreciated) &r" + C.CLEARING_DONE.s().replaceAll("%time%", "" + ((System.nanoTime() - start) / 1000000.0)));
            return;
        }
        int startX = (pos1.getBlockX() / 16) * 16;
        int startZ = (pos1.getBlockZ() / 16) * 16;
        int chunkX = 16 + pos2.getBlockX();
        int chunkZ = 16 + pos2.getBlockZ();
        Location l1 = getPlotBottomLoc(world, plot.id);
        Location l2 = getPlotTopLoc(world, plot.id);
        int plotMinX = l1.getBlockX() + 1;
        int plotMinZ = l1.getBlockZ() + 1;
        int plotMaxX = l2.getBlockX();
        int plotMaxZ = l2.getBlockZ();
        Location min = null;
        Location max = null;
        for (int i = startX; i < chunkX; i += 16) {
            for (int j = startZ; j < chunkZ; j += 16) {
                Plot plot1 = getCurrentPlot(new Location(world, i, 0, j));
                if ((plot1 != null) && (plot1.getId() != plot.getId()) && plot1.hasOwner()) {
                    break;
                }
                Plot plot2 = getCurrentPlot(new Location(world, i + 15, 0, j));
                if ((plot2 != null) && (plot2.getId() != plot.getId()) && plot2.hasOwner()) {
                    break;
                }
                Plot plot3 = getCurrentPlot(new Location(world, i + 15, 0, j + 15));
                if ((plot3 != null) && (plot3.getId() != plot.getId()) && plot3.hasOwner()) {
                    break;
                }
                Plot plot4 = getCurrentPlot(new Location(world, i, 0, j + 15));
                if ((plot4 != null) && (plot4.getId() != plot.getId()) && plot4.hasOwner()) {
                    break;
                }
                Plot plot5 = getCurrentPlot(new Location(world, i + 15, 0, j + 15));
                if ((plot5 != null) && (plot5.getId() != plot.getId()) && plot5.hasOwner()) {
                    break;
                }
                if (min == null) {
                    min = new Location(world, Math.max(i - 1, plotMinX), 0, Math.max(j - 1, plotMinZ));
                    max = new Location(world, Math.min(i + 16, plotMaxX), 0, Math.min(j + 16, plotMaxZ));
                } else if ((max.getBlockZ() < (j + 15)) || (max.getBlockX() < (i + 15))) {
                    max = new Location(world, Math.min(i + 16, plotMaxX), 0, Math.min(j + 16, plotMaxZ));
                }
                world.regenerateChunk(i / 16, j / 16);
            }
        }

        if (min == null) {
            setSimpleCuboid(world, new Location(world, pos1.getBlockX(), 0, pos1.getBlockZ()), new Location(world, pos2.getBlockX() + 1, 1, pos2.getBlockZ() + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, pos1.getBlockX(), plotworld.PLOT_HEIGHT + 1, pos1.getBlockZ()), new Location(world, pos2.getBlockX() + 1, world.getMaxHeight() + 1, pos2.getBlockZ() + 1), (short) 0);
            setCuboid(world, new Location(world, pos1.getBlockX(), 1, pos1.getBlockZ()), new Location(world, pos2.getBlockX() + 1, plotworld.PLOT_HEIGHT, pos2.getBlockZ() + 1), filling, filling_data);
            setCuboid(world, new Location(world, pos1.getBlockX(), plotworld.PLOT_HEIGHT, pos1.getBlockZ()), new Location(world, pos2.getBlockX() + 1, plotworld.PLOT_HEIGHT + 1, pos2.getBlockZ() + 1), plotfloors, plotfloors_data);
        } else {
            
            if (min.getBlockX() < plotMinX) {
                min.setX(plotMinX);
            }
            if (min.getBlockZ() < plotMinZ) {
                min.setZ(plotMinZ);
            }
            if (max.getBlockX() > plotMaxX) {
                max.setX(plotMaxX);
            }
            if (max.getBlockZ() > plotMaxZ) {
                max.setZ(plotMaxZ);
            }
            
            setSimpleCuboid(world, new Location(world, plotMinX, 0, plotMinZ), new Location(world, min.getBlockX() + 1, 1, min.getBlockZ() + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, plotMinX, plotworld.PLOT_HEIGHT + 1, plotMinZ), new Location(world, min.getBlockX() + 1, world.getMaxHeight() + 1, min.getBlockZ() + 1), (short) 0);
            setCuboid(world, new Location(world, plotMinX, 1, plotMinZ), new Location(world, min.getBlockX() + 1, plotworld.PLOT_HEIGHT + 1, min.getBlockZ() + 1), filling, filling_data);
            setCuboid(world, new Location(world, plotMinX, plotworld.PLOT_HEIGHT, plotMinZ), new Location(world, min.getBlockX() + 1, plotworld.PLOT_HEIGHT + 1, min.getBlockZ() + 1), plotfloors, plotfloors_data);

            setSimpleCuboid(world, new Location(world, min.getBlockX(), 0, plotMinZ), new Location(world, max.getBlockX() + 1, 1, min.getBlockZ() + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, min.getBlockX(), plotworld.PLOT_HEIGHT + 1, plotMinZ), new Location(world, max.getBlockX() + 1, world.getMaxHeight() + 1, min.getBlockZ() + 1), (short) 0);
            setCuboid(world, new Location(world, min.getBlockX(), 1, plotMinZ), new Location(world, max.getBlockX() + 1, plotworld.PLOT_HEIGHT, min.getBlockZ() + 1), filling, filling_data);
            setCuboid(world, new Location(world, min.getBlockX(), plotworld.PLOT_HEIGHT, plotMinZ), new Location(world, max.getBlockX() + 1, plotworld.PLOT_HEIGHT + 1, min.getBlockZ() + 1), plotfloors, plotfloors_data);

            setSimpleCuboid(world, new Location(world, max.getBlockX(), 0, plotMinZ), new Location(world, plotMaxX + 1, 1, min.getBlockZ() + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, max.getBlockX(), plotworld.PLOT_HEIGHT + 1, plotMinZ), new Location(world, plotMaxX + 1, world.getMaxHeight() + 1, min.getBlockZ() + 1), (short) 0);
            setCuboid(world, new Location(world, max.getBlockX(), 1, plotMinZ), new Location(world, plotMaxX + 1, plotworld.PLOT_HEIGHT, min.getBlockZ() + 1), filling, filling_data);
            setCuboid(world, new Location(world, max.getBlockX(), plotworld.PLOT_HEIGHT, plotMinZ), new Location(world, plotMaxX + 1, plotworld.PLOT_HEIGHT + 1, min.getBlockZ() + 1), plotfloors, plotfloors_data);

            setSimpleCuboid(world, new Location(world, plotMinX, 0, min.getBlockZ()), new Location(world, min.getBlockX() + 1, 1, max.getBlockZ() + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, plotMinX, plotworld.PLOT_HEIGHT + 1, min.getBlockZ()), new Location(world, min.getBlockX() + 1, world.getMaxHeight() + 1, max.getBlockZ() + 1), (short) 0);
            setCuboid(world, new Location(world, plotMinX, 1, min.getBlockZ()), new Location(world, min.getBlockX() + 1, plotworld.PLOT_HEIGHT, max.getBlockZ() + 1), filling, filling_data);
            setCuboid(world, new Location(world, plotMinX, plotworld.PLOT_HEIGHT, min.getBlockZ()), new Location(world, min.getBlockX() + 1, plotworld.PLOT_HEIGHT + 1, max.getBlockZ() + 1), plotfloors, plotfloors_data);

            setSimpleCuboid(world, new Location(world, plotMinX, 0, max.getBlockZ()), new Location(world, min.getBlockX() + 1, 1, plotMaxZ + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, plotMinX, plotworld.PLOT_HEIGHT + 1, max.getBlockZ()), new Location(world, min.getBlockX() + 1, world.getMaxHeight() + 1, plotMaxZ + 1), (short) 0);
            setCuboid(world, new Location(world, plotMinX, 1, max.getBlockZ()), new Location(world, min.getBlockX() + 1, plotworld.PLOT_HEIGHT, plotMaxZ + 1), filling, filling_data);
            setCuboid(world, new Location(world, plotMinX, plotworld.PLOT_HEIGHT, max.getBlockZ()), new Location(world, min.getBlockX() + 1, plotworld.PLOT_HEIGHT + 1, plotMaxZ + 1), plotfloors, plotfloors_data);

            setSimpleCuboid(world, new Location(world, min.getBlockX(), 0, max.getBlockZ()), new Location(world, max.getBlockX() + 1, 1, plotMaxZ + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, min.getBlockX(), plotworld.PLOT_HEIGHT + 1, max.getBlockZ()), new Location(world, max.getBlockX() + 1, world.getMaxHeight() + 1, plotMaxZ + 1), (short) 0);
            setCuboid(world, new Location(world, min.getBlockX(), 1, max.getBlockZ()), new Location(world, max.getBlockX() + 1, plotworld.PLOT_HEIGHT, plotMaxZ + 1), filling, filling_data);
            setCuboid(world, new Location(world, min.getBlockX(), plotworld.PLOT_HEIGHT, max.getBlockZ()), new Location(world, max.getBlockX() + 1, plotworld.PLOT_HEIGHT + 1, plotMaxZ + 1), plotfloors, plotfloors_data);

            setSimpleCuboid(world, new Location(world, max.getBlockX(), 0, min.getBlockZ()), new Location(world, plotMaxX + 1, 1, max.getBlockZ() + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, max.getBlockX(), plotworld.PLOT_HEIGHT + 1, max.getBlockZ()), new Location(world, plotMaxX + 1, world.getMaxHeight() + 1, plotMaxZ + 1), (short) 0);
            setCuboid(world, new Location(world, max.getBlockX(), 1, min.getBlockZ()), new Location(world, plotMaxX + 1, plotworld.PLOT_HEIGHT, max.getBlockZ() + 1), filling, filling_data);
            setCuboid(world, new Location(world, max.getBlockX(), plotworld.PLOT_HEIGHT, min.getBlockZ()), new Location(world, plotMaxX + 1, plotworld.PLOT_HEIGHT + 1, max.getBlockZ() + 1), plotfloors, plotfloors_data);

            setSimpleCuboid(world, new Location(world, max.getBlockX(), 0, max.getBlockZ()), new Location(world, plotMaxX + 1, 1, plotMaxZ + 1), (short) 7);
            setSimpleCuboid(world, new Location(world, max.getBlockX(), plotworld.PLOT_HEIGHT + 1, max.getBlockZ()), new Location(world, plotMaxX + 1, world.getMaxHeight() + 1, plotMaxZ + 1), (short) 0);
            setCuboid(world, new Location(world, max.getBlockX(), 1, max.getBlockZ()), new Location(world, plotMaxX + 1, plotworld.PLOT_HEIGHT, plotMaxZ + 1), filling, filling_data);
            setCuboid(world, new Location(world, max.getBlockX(), plotworld.PLOT_HEIGHT, max.getBlockZ()), new Location(world, plotMaxX + 1, plotworld.PLOT_HEIGHT + 1, plotMaxZ + 1), plotfloors, plotfloors_data);
        }
        
        
        /*
         * keep
         */
        PlayerFunctions.sendMessage(requester, C.CLEARING_DONE.s().replaceAll("%time%", "" + ((System.nanoTime() - start) / 1000000.0)));
        if (canSetFast) {
            SetBlockFast.update(requester);
        }
        return;
    }

    public static void setCuboid(World world, Location pos1, Location pos2, PlotBlock[] blocks) {
        if (!canSetFast) {
            for (int y = pos1.getBlockY(); y < pos2.getBlockY(); y++) {
                for (int x = pos1.getBlockX(); x < pos2.getBlockX(); x++) {
                    for (int z = pos1.getBlockZ(); z < pos2.getBlockZ(); z++) {
                        int i = random(blocks.length);
                        PlotBlock newblock = blocks[i];
                        Block block = world.getBlockAt(x, y, z);
                        if (!((block.getTypeId() == newblock.id) && (block.getData() == newblock.data))) {
                            block.setTypeIdAndData(newblock.id, newblock.data, false);
                        }
                    }
                }
            }
        } else {
            try {
                for (int y = pos1.getBlockY(); y < pos2.getBlockY(); y++) {
                    for (int x = pos1.getBlockX(); x < pos2.getBlockX(); x++) {
                        for (int z = pos1.getBlockZ(); z < pos2.getBlockZ(); z++) {
                            int i = random(blocks.length);
                            PlotBlock newblock = blocks[i];
                            Block block = world.getBlockAt(x, y, z);
                            if (!((block.getTypeId() == newblock.id) && (block.getData() == newblock.data))) {
                                SetBlockFast.set(world, x, y, z, newblock.id, newblock.data);
                            }
                        }
                    }
                }
            } catch (Exception e) {
            }
        }
    }

    public static void setSimpleCuboid(World world, Location pos1, Location pos2, PlotBlock newblock) {
        if (!canSetFast) {
            for (int y = pos1.getBlockY(); y < pos2.getBlockY(); y++) {
                for (int x = pos1.getBlockX(); x < pos2.getBlockX(); x++) {
                    for (int z = pos1.getBlockZ(); z < pos2.getBlockZ(); z++) {
                        Block block = world.getBlockAt(x, y, z);
                        if (!((block.getTypeId() == newblock.id))) {
                            block.setTypeId(newblock.id, false);
                        }
                    }
                }
            }
        } else {
            try {
                for (int y = pos1.getBlockY(); y < pos2.getBlockY(); y++) {
                    for (int x = pos1.getBlockX(); x < pos2.getBlockX(); x++) {
                        for (int z = pos1.getBlockZ(); z < pos2.getBlockZ(); z++) {
                            Block block = world.getBlockAt(x, y, z);
                            if (!((block.getTypeId() == newblock.id))) {
                                SetBlockFast.set(world, x, y, z, newblock.id, (byte) 0);
                            }
                        }
                    }
                }
            } catch (Exception e) {

            }
        }
    }

    public static void setBiome(World world, Plot plot, Biome b) {
        int bottomX = getPlotBottomLoc(world, plot.id).getBlockX() - 1;
        int topX = getPlotTopLoc(world, plot.id).getBlockX() + 1;
        int bottomZ = getPlotBottomLoc(world, plot.id).getBlockZ() - 1;
        int topZ = getPlotTopLoc(world, plot.id).getBlockZ() + 1;

        for (int x = bottomX; x <= topX; x++) {
            for (int z = bottomZ; z <= topZ; z++) {
                world.getBlockAt(x, 0, z).setBiome(b);
            }
        }

        plot.settings.setBiome(b);
        PlotMain.updatePlot(plot);
        refreshPlotChunks(world, plot);
    }

    public static Location getPlotHome(World w, Plot plot) {
        PlotWorld plotworld = PlotMain.getWorldSettings(w);
        if (plot.settings.getPosition() == PlotHomePosition.DEFAULT) {
            int x = getPlotBottomLoc(w, plot.id).getBlockX() + (getPlotTopLoc(w, plot.id).getBlockX() - getPlotBottomLoc(w, plot.id).getBlockX());
            int z = getPlotBottomLoc(w, plot.id).getBlockZ() - 2;
            return new Location(w, x, plotworld.ROAD_HEIGHT + 2, z);
        } else {
            World world = w;
            int x1 = getPlotBottomLoc(world, plot.id).getBlockX();
            int x2 = x1 + plotworld.PLOT_WIDTH;
            int z1 = getPlotBottomLoc(world, plot.id).getBlockZ();
            int z2 = z1 + plotworld.PLOT_WIDTH;

            int xMin = Math.min(x1, x2) + 1;
            // int xMax = Math.max(x1, x2);

            int zMin = Math.min(z1, z2) + 1;
            // int zMax = Math.max(z1, z2);

            double adder = (plotworld.PLOT_WIDTH / 2);
            double x = (xMin + adder), y = plotworld.ROAD_HEIGHT + 3, z = (zMin + adder);
            return new Location(world, x, y, z);
        }
    }

    public static Location getPlotHome(World w, PlotId id) {
        PlotWorld plotworld = PlotMain.getWorldSettings(w);
        if (getPlot(w, id).settings.getPosition() == PlotHomePosition.DEFAULT) {
            int x = getPlotBottomLoc(w, id).getBlockX() + (getPlotTopLoc(w, id).getBlockX() - getPlotBottomLoc(w, id).getBlockX());
            int z = getPlotBottomLoc(w, id).getBlockZ() - 2;
            return new Location(w, x, plotworld.ROAD_HEIGHT + 2, z);
        } else {
            World world = w;
            int x1 = getPlotBottomLoc(world, id).getBlockX();
            int x2 = x1 + plotworld.PLOT_WIDTH;
            int z1 = getPlotBottomLoc(world, id).getBlockZ();
            int z2 = z1 + plotworld.PLOT_WIDTH;

            int xMin = Math.min(x1, x2) + 1;
            Math.max(x1, x2);

            int zMin = Math.min(z1, z2) + 1;
            Math.max(z1, z2);

            double adder = (plotworld.PLOT_WIDTH / 2);
            double x = (xMin + adder), y = plotworld.ROAD_HEIGHT + 3, z = (zMin + adder);
            return new Location(world, x, y, z);
        }
    }

    public static void refreshPlotChunks(World world, Plot plot) {
        int bottomX = getPlotBottomLoc(world, plot.id).getBlockX();
        int topX = getPlotTopLoc(world, plot.id).getBlockX();
        int bottomZ = getPlotBottomLoc(world, plot.id).getBlockZ();
        int topZ = getPlotTopLoc(world, plot.id).getBlockZ();

        int minChunkX = (int) Math.floor((double) bottomX / 16);
        int maxChunkX = (int) Math.floor((double) topX / 16);
        int minChunkZ = (int) Math.floor((double) bottomZ / 16);
        int maxChunkZ = (int) Math.floor((double) topZ / 16);

        for (int x = minChunkX; x <= maxChunkX; x++) {
            for (int z = minChunkZ; z <= maxChunkZ; z++) {
                world.refreshChunk(x, z);
            }
        }
    }

    public static Location getPlotTopLocAbs(World world, PlotId id) {
        PlotWorld plotworld = PlotMain.getWorldSettings(world);
        int px = id.x;
        int pz = id.y;

        int x = (px * (plotworld.ROAD_WIDTH + plotworld.PLOT_WIDTH)) - ((int) Math.floor(plotworld.ROAD_WIDTH / 2)) - 1;
        int z = (pz * (plotworld.ROAD_WIDTH + plotworld.PLOT_WIDTH)) - ((int) Math.floor(plotworld.ROAD_WIDTH / 2)) - 1;

        return new Location(world, x, 255, z);
    }

    public static Location getPlotBottomLocAbs(World world, PlotId id) {
        PlotWorld plotworld = PlotMain.getWorldSettings(world);
        int px = id.x;
        int pz = id.y;

        int x = (px * (plotworld.ROAD_WIDTH + plotworld.PLOT_WIDTH)) - plotworld.PLOT_WIDTH - ((int) Math.floor(plotworld.ROAD_WIDTH / 2)) - 1;
        int z = (pz * (plotworld.ROAD_WIDTH + plotworld.PLOT_WIDTH)) - plotworld.PLOT_WIDTH - ((int) Math.floor(plotworld.ROAD_WIDTH / 2)) - 1;

        return new Location(world, x, 1, z);
    }

    public static Location getPlotTopLoc(World world, PlotId id) {
        Plot plot = PlotMain.getPlots(world).get(id);
        if (plot != null) {
            id = PlayerFunctions.getTopPlot(world, plot).id;
        }
        PlotWorld plotworld = PlotMain.getWorldSettings(world);
        int px = id.x;
        int pz = id.y;

        int x = (px * (plotworld.ROAD_WIDTH + plotworld.PLOT_WIDTH)) - ((int) Math.floor(plotworld.ROAD_WIDTH / 2)) - 1;
        int z = (pz * (plotworld.ROAD_WIDTH + plotworld.PLOT_WIDTH)) - ((int) Math.floor(plotworld.ROAD_WIDTH / 2)) - 1;

        return new Location(world, x, 255, z);
    }

    public static Location getPlotBottomLoc(World world, PlotId id) {
        Plot plot = PlotMain.getPlots(world).get(id);
        if (plot != null) {
            id = PlayerFunctions.getBottomPlot(world, plot).id;
        }
        PlotWorld plotworld = PlotMain.getWorldSettings(world);
        int px = id.x;
        int pz = id.y;

        int x = (px * (plotworld.ROAD_WIDTH + plotworld.PLOT_WIDTH)) - plotworld.PLOT_WIDTH - ((int) Math.floor(plotworld.ROAD_WIDTH / 2)) - 1;
        int z = (pz * (plotworld.ROAD_WIDTH + plotworld.PLOT_WIDTH)) - plotworld.PLOT_WIDTH - ((int) Math.floor(plotworld.ROAD_WIDTH / 2)) - 1;

        return new Location(world, x, 1, z);
    }

    public static Plot getPlot(World world, PlotId id) {
        if (id == null) {
            return null;
        }
        if (PlotMain.getPlots(world).containsKey(id)) {
            return PlotMain.getPlots(world).get(id);
        }
        return new Plot(id, null, Biome.FOREST, new ArrayList<UUID>(), new ArrayList<UUID>(), world.getName());
    }

    public static Plot getCurrentPlot(Location loc) {
        /*
         * Vector vector = player.getLocation().toVector(); for(plot plot :
         * getPlots()) if(vector.isInAABB(plot.l1.toVector(),
         * plot.l2.toVector())) return plot; return null;
         */
        PlotId id = PlayerFunctions.getPlot(loc);
        if (id == null) {
            return null;
        }
        if (PlotMain.getPlots(loc.getWorld()).containsKey(id)) {
            return PlotMain.getPlots(loc.getWorld()).get(id);
        }
        return new Plot(id, null, Biome.FOREST, new ArrayList<UUID>(), new ArrayList<UUID>(), loc.getWorld().getName());
    }
}
